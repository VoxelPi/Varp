package net.voxelpi.varp.environment

import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.launch
import net.voxelpi.varp.environment.model.EnvironmentDefinition
import net.voxelpi.varp.environment.model.MountDefinition
import net.voxelpi.varp.environment.model.RepositoryDefinition
import net.voxelpi.varp.repository.Repository
import net.voxelpi.varp.repository.RepositoryConfig
import net.voxelpi.varp.repository.RepositoryType
import net.voxelpi.varp.repository.compositor.Compositor
import net.voxelpi.varp.repository.compositor.CompositorMount
import net.voxelpi.varp.tree.Tree
import org.slf4j.Logger
import org.slf4j.LoggerFactory

public class VarpEnvironment internal constructor() {

    private val logger: Logger = LoggerFactory.getLogger(VarpEnvironmentLoader::class.java)

    private val _repositories: MutableMap<String, Repository> = mutableMapOf()

    /**
     * The currently loaded repositories.
     */
    public val repositories: Map<String, Repository>
        get() = _repositories

    /**
     * The compositor that is generated by the loader.
     */
    public val compositor: Compositor = Compositor.empty("main")

    /**
     * The tree of the compositor.
     */
    public val tree: Tree
        get() = compositor.tree

    public fun registerRepository(repository: Repository) {
        _repositories[repository.id] = repository
    }

    public fun unregisterRepository(id: String): Repository? {
        return _repositories.remove(id)
    }

    public suspend fun load(environmentDefinition: EnvironmentDefinition): Result<Unit> = runCatching {
        // Deactivating all previously loaded repositories.
        coroutineScope {
            for (repository in _repositories.values) {
                launch {
                    repository.deactivate()
                }
            }
        }

        // Load new repositories.
        _repositories.clear()
        for ((repoId, repoDefinition) in environmentDefinition.repositories) {
            @Suppress("UNCHECKED_CAST")
            val repository = (repoDefinition.type as RepositoryType<Repository, RepositoryConfig>).create(repoId, repoDefinition.config).getOrElse {
                logger.error("Could not load repository '$repoId': ${it.message}", it)
                continue
            }
            _repositories[repository.id] = repository
        }

        // Activate all repositories.
        coroutineScope {
            for (repository in _repositories.values) {
                launch {
                    repository.activate().onFailure {
                        logger.error("Could not activate repository '${repository.id}': ${it.message}", it)
                    }
                }
            }
        }

        // Update compositor mounts.
        val mounts = environmentDefinition.mounts.mapNotNull { (location, definition) ->
            val repository = repositories[definition.repository] ?: run {
                logger.error("Unable to create mount, unknown repository \"${definition.repository}\"")
                return@mapNotNull null
            }
            CompositorMount(location, repository, definition.path)
        }
        compositor.modifyMounts(mounts).getOrThrow()
    }

    /**
     * Deactivates the compositor and all loaded repositories.
     */
    public suspend fun deactivate(): Result<Unit> = runCatching {
        // Deactivate the compositor.
        compositor.deactivate().getOrThrow()

        // Deactivate all existing repositories.
        coroutineScope {
            for (repository in repositories.values) {
                launch {
                    repository.deactivate().getOrThrow()
                }
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    public fun save(): EnvironmentDefinition {
        return EnvironmentDefinition(
            repositories.mapValues { RepositoryDefinition.repositoryDefinition(it.value) },
            compositor.mounts().associate { it.path to MountDefinition(it.repository.id, it.sourcePath) },
        )
    }

    public companion object {

        public suspend fun environment(definition: EnvironmentDefinition): Result<VarpEnvironment> {
            val environment = VarpEnvironment()
            environment.load(definition)
            return Result.success(environment)
        }
    }
}
